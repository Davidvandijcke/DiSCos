perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
1/33
2/33
1/34
2/34
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
devtools::load_all()
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
DiSCO_CI
DiSCo_CI
DiSCo_CI_iter
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
RNGkind("L'Ecuyer-CMRG")
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
set.seed(24)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
?mc.reset.stream
devtools::load_all()
# Load required packages
packages_load <- c("haven", "base", "data.table", "latex2exp", "CVXR",  # used to compute the weights using the alternative using mixtures of CDF
"here", "dplyr", "pracma", "quadprog", "R.utils", "foreach", "DiSCo")
if (!require("pacman")) install.packages("pacman")
pacman::p_load(char = packages_load, character.only = TRUE)
# Set the working directory
setwd(file.path(here::here()))
#####
# Values to be chosen by the researcher
M <- 1000 # draws for samples to compute the respective integrals.
fips.target <- 2 # target state is AK
#####
#####
# loading the data-set on minimum wage from Dube (2019) to obtain states that did not have a
# change of the minimum wage between 1998-2014
df <- read_dta(file.path("data", "mw_annual_lagsleads_19
74_2014.dta"))
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
id_col.target <- 2
t0 <- 2003
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.8, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.7, per_q_max=1)
perm$pemr
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.7, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.7, per_q_max=0.95)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 100, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.5, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.5, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE, seed=seed,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.5, per_q_max=1)
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE, seed=25,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.5, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE, seed=25,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0.5, per_q_max=1)
perm$perm
perm <- DiSCo(dube, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = TRUE, seed=25,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL, per_q_min = 0, per_q_max=1)
perm$perm
dube
summary(dube$y_col)
quantile(dube$y_col, 0.95)
quantile(dube$y_col, 0.999)
quantile(dube$y_col, 0.95)
df <- copy(dube)
df <- df[y_col <= quantile(y_col, 0.95), ]
df
nrow(df)
nrow(dube)
disco <- DiSCo::DiSCo(df, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = FALSE,
CI = TRUE, boots = 1000, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL)
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL)
DiSCoTEA(disco,  agg="cdfTreat", graph=TRUE, time=TRUE, n_per_window=NULL)
DiSCoTEA(disco,  agg="cdfDiff", graph=TRUE, time=TRUE, n_per_window=NULL)
?plot
devtools::load_all()
DiSCoTEA(disco,  agg="cdfDiff", graph=TRUE, time=TRUE, n_per_window=NULL)
devtools::load_all()
# reconstruct some parameters
df <- disco$params$df
t_max <- max(df$time_col)
t_min <- min(df$time_col)
t0 <- disco$params$t0
T0 <- unique(df[time_col == t0]$t_col)  - 1
T_max <- max(df$t_col)
CI <- disco$params$CI
cl <- disco$params$cl
placebo <- disco$params$CI_placebo
evgrid = seq(from=0,to=1,length.out=disco$params$G+1)
qmethod <- disco$params$qmethod
#
if (is.null(n_per_window)) n_per_window <- T_max
n_per_window <- NULL
# reconstruct some parameters
df <- disco$params$df
t_max <- max(df$time_col)
t_min <- min(df$time_col)
t0 <- disco$params$t0
T0 <- unique(df[time_col == t0]$t_col)  - 1
T_max <- max(df$t_col)
CI <- disco$params$CI
cl <- disco$params$cl
placebo <- disco$params$CI_placebo
evgrid = seq(from=0,to=1,length.out=disco$params$G+1)
qmethod <- disco$params$qmethod
#
if (is.null(n_per_window)) n_per_window <- T_max
if (!placebo) {
t_start <- t0
T_start <- T0+1
} else{
t_start <- t_min
T_start <- 1
}
# calculate quantile treatment effects
qtiles_centered <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$DiSCo$quantile - disco$results.periods[[x]]$target$quantiles)
if (CI) { # calculate CI quantile treatment effects
qtiles_centered_boot <- lapply(T_start:T_max, function(x) disco$results.periods[[x]]$DiSCo$CI$bootmat - disco$results.periods[[x]]$target$quantiles)
}
target_qtiles <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$target$quantiles)
#
#   qtiles_centered <- lapply(T_start:T_max,
#                    function(x) disco$results.periods[[x]]$target$quantiles)
#   qtiles_centered_boot <- lapply(T_start:T_max,
#                         function(x) disco$results.periods[[x]]$DiSCo$CI$bootmat)
treats <- list()
treats_boot <- list()
grid_temp <- disco$results.periods[[1]]$target$grid ## TODO: in future probably wanna address this at root by always taking same grid in DiSco
for (i in 1:length(disco$results.periods)) {
c_cdf <- stats::ecdf(disco$results.periods[[i]]$DiSCo$quantile)(grid_temp)
t_cdf <- stats::ecdf(disco$results.periods[[i]]$target$quantile)(grid_temp)
treats[[i]] <- c_cdf - t_cdf
boot_cdf <- apply(disco$results.periods[[i]]$DiSCo$CI$bootmat, 2, function(x) stats::ecdf(x)(grid_temp))
treats_boot[[i]] <- sweep(boot_cdf, 1, t_cdf, "-")
}
if (CI){
sds <- list()
ci_lower <- list()
ci_upper <- list()
for (i in 1:length(disco$results.periods)) {
sds[[i]] <- apply(treats_boot[[i]], 1, sd)
ci_lower[[i]] <- apply(treats_boot[[i]],1,stats::quantile, probs=(1-cl)/2)
ci_upper[[i]] <- apply(treats_boot[[i]],1,stats::quantile, probs=cl+(1-cl)/2)
}
} else {
sds <- NA
ci_lower <- NA
ci_upper <- NA
}
floor(quantile(unlist(treats), 0.01))
floor(quantile(unlist(treats), 0.05))
floor(quantile(unlist(treats), 0.1))
treats
summary(unlist(treats))
devtools::load_all()
DiSCoTEA(disco,  agg="cdfDiff", graph=TRUE, time=TRUE, n_per_window=NULL)
DiSCoTEA(disco,  agg="cdf", graph=TRUE, time=TRUE, n_per_window=NULL)
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL)
disco <- DiSCo::DiSCo(df, id_col.target, t0, M = 10000, G = 1000, num.cores = 5, permutation = FALSE,
CI = TRUE, boots = 1000, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL)
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- 1:(disco$params$G+1) / (disco$params$G+1)
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
length(target)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- 1:(disco$params$G) / (disco$params$G)
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
DiSCoTEA(disco,  agg="cdfDiff", graph=TRUE, time=TRUE, n_per_window=NULL)
DiSCoTEA(disco,  agg="quantile", graph=TRUE, time=TRUE, n_per_window=NULL)
# reconstruct some parameters
df <- disco$params$df
t_max <- max(df$time_col)
t_min <- min(df$time_col)
t0 <- disco$params$t0
T0 <- unique(df[time_col == t0]$t_col)  - 1
T_max <- max(df$t_col)
CI <- disco$params$CI
cl <- disco$params$cl
placebo <- disco$params$CI_placebo
evgrid = seq(from=0,to=1,length.out=disco$params$G+1)
qmethod <- disco$params$qmethod
#
if (is.null(n_per_window)) n_per_window <- T_max
if (!placebo) {
t_start <- t0
T_start <- T0+1
} else{
t_start <- t_min
T_start <- 1
}
# calculate quantile treatment effects
qtiles_centered <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$DiSCo$quantile - disco$results.periods[[x]]$target$quantiles)
if (CI) { # calculate CI quantile treatment effects
qtiles_centered_boot <- lapply(T_start:T_max, function(x) disco$results.periods[[x]]$DiSCo$CI$bootmat - disco$results.periods[[x]]$target$quantiles)
}
target_qtiles <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$target$quantiles)
#
qtiles <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$DiSCo$quantile)
target_qtiles <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$target$quantiles)
qtiles_boot <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$DiSCo$CI$bootmat)
treats <-  qtiles
grid <- evgrid
dim(qtiles_boot)
length(qtiles_boot)
dim(qtiles_boot[[1]])
apply(quantiles_boot[[1]],1,stats::quantile, probs=(1-cl)/2)
apply(qtiles_boot[[1]],1,stats::quantile, probs=(1-cl)/2)
dim(apply(qtiles_boot[[1]],1,stats::quantile, probs=(1-cl)/2))
dim(apply(qtiles_boot[[1]])
)
dim(qtiles_boot[[q]])
dim(qtiles_boot[[1]])
dim(apply(qtiles_boot[[1]],1,stats::quantile, probs=(1-cl)/2))
apply(qtiles_boot[[1]],1,stats::quantile, probs=(1-cl)/2)
length(apply(qtiles_boot[[1]],1,stats::quantile, probs=(1-cl)/2))
qtiles <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$DiSCo$quantile)
target_qtiles <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$target$quantiles)
qtiles_boot <- lapply(T_start:T_max,
function(x) disco$results.periods[[x]]$DiSCo$CI$bootmat)
treats <-  qtiles
grid <- evgrid
if (CI) {
sds <- lapply(qtiles_boot, function(x) apply(x, 1, sd))
ci_lower <- lapply(qtiles_boot, function(x) apply(x,1,stats::quantile, probs=(1-cl)/2))
ci_upper <- lapply(qtiles_boot, function(x) apply(x,1,stats::quantile, probs=cl+(1-cl)/2))
} else {
sds <- NA
ci_lower <- NA
ci_upper <- NA
}
plotDistOverTime(treats, grid, t_start, t_max, n_per_window, CI, ci_lower, ci_upper, ylim=ylim, xlab="Quantile",
ylab="Treatment Effect", cdf=FALSE, obsLine = target_qtiles, savePlots=savePlots, plotName=agg)
savePlots <- FALSE
plotDistOverTime(treats, grid, t_start, t_max, n_per_window, CI, ci_lower, ci_upper, ylim=ylim, xlab="Quantile",
ylab="Treatment Effect", cdf=FALSE, obsLine = target_qtiles, savePlots=savePlots, plotName=agg)
ymin <- quantile(unlist(qtiles), 0.01)
ymax <- quantile(unlist(qtiles), 0.99)
ylim <- c(ymin, ymax)
plotDistOverTime(treats, grid, t_start, t_max, n_per_window, CI, ci_lower, ci_upper, ylim=ylim, xlab="Quantile",
ylab="Treatment Effect", cdf=FALSE, obsLine = target_qtiles, savePlots=savePlots, plotName=agg)
ci_lower
ci_upper
treats
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL)
disco <- DiSCo::DiSCo(df, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = FALSE,
CI = TRUE, boots = 1000, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL)
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL)
df <- copy(dube)
# df <- df[y_col <= quantile(y_col, 0.95), ]
disco <- DiSCo::DiSCo(df, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = FALSE,
CI = TRUE, boots = 1000, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL)
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL)
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL, ylim = c(-0.3,0.3))
df <- copy(dube)
df <- df[y_col <= quantile(y_col, 0.95), ]
disco <- DiSCo::DiSCo(df, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = FALSE,
CI = TRUE, boots = 5000, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL)
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL, ylim = c(-0.3,0.3))
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL, ylim = c(-0.3,0.3))
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
DiSCoTEA(disco,  agg="quantileTreat", graph=TRUE, time=TRUE, n_per_window=NULL, ylim = c(-0.3,0.3))
disco <- DiSCo::DiSCo(df, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = FALSE,
CI = TRUE, boots = 1000, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
id_col.target <- 2
t0 <- 2003
df <- copy(dube)
#df <- df[y_col <= quantile(y_col, 0.95), ]
disco <- DiSCo::DiSCo(df, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = FALSE,
CI = TRUE, boots = 1000, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
max(grid_pord)
max(grid_ord)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
library(DiSCo)
data("dube")
df <- copy(dube)
set.seed(1860)
id_col.target <- 2
t0 <- 2003
df <- copy(dube)
disco <- DiSCo::DiSCo(df, id_col.target, t0, M = 1000, G = 1000, num.cores = 5, permutation = FALSE,
CI = TRUE, boots = 1, cl = 0.95,  CI_placebo=TRUE, graph = TRUE, qmethod=NULL)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='blue', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=4,col='black', xlab='Quantile',ylab='Treatment Effect',cex.lab=1.4, cex.axis=1.4, lty=3)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
# plot quantiles
target <- disco$results.periods$`1999`$target$cdf
grid_ord <- disco$results.periods$`1999`$target$grid
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, target,
type='l', lwd=3,col='black', xlab='Quantile',ylab='Treatment Effect', lty=3)
lines(grid_ord, bc,lwd=4, col='red', lty=2)
bc <- disco$results.periods$`1999`$DiSCo$cdf
plot(grid_ord, bc, cex.lab=1.4, cex.axis=1.4,
type='l', lwd=4,col='red', xlab='Quantile',ylab='Treatment Effect', lty=2)
lines(grid_ord, target,lwd=3, col='black', lty=3)
# Code for replicating the images in section 5 of the paper "Distributional Synthetic Controls"
# by Florian Gunsilius, Siyun He, and David Van Dijcke, February 2023.
# This code uses publicly available data provided as a supplement to the published article
# "Minimum Wages and the Distribution of Family Incomes" (Dube, 2019, AEJ: Applied).
# The replication package to that article along with the data can be accessed at
# https://www.dropbox.com/s/hrmz2fu0lxet97c/Minimum%20Wage%20Poverty%20Replication.zip?dl=0
# We converted the .dta file to compressed csv to reduce the filesize
# This code comes with no guarantees. The compressed package also contains an unused function
# DiSCo_CI, which is not used in this replication, but can be used to compute the confidence
# intervals of the corresponding quantile functions.
#####
# Load required packages
packages_load <- c("haven", "base", "data.table", "latex2exp", "CVXR",  # used to compute the weights using the alternative using mixtures of CDF
"here", "dplyr", "pracma", "quadprog", "R.utils", "foreach", "maps")
if (!require("pacman")) install.packages("pacman")
pacman::p_load(char = packages_load, character.only = TRUE)
# Set the working directory
setwd(file.path(here::here()))
#####
# Values to be chosen by the researcher
M <- 1000 # draws for samples to compute the respective integrals.
fips.target <- 2 # target state is AK
#####
# Required functions
# loading the function for computing the optimal weights
source('R/DiSCo_weights_reg.R')
# loading the function for computing the barycenter and the donor distributions
source('R/DiSCo_bc.R')
# loading the function for performing the permutation test
source('R/DiSCo_per.R')
## function to compute quantile function
myquant <- function(X,q){
# sort if unsorted
if (is.unsorted(X)) X <- sort(X)
# compute empirical CDF
X.cdf <- 1:length(X) / length(X)
# obtain the corresponding empirical quantile
return(X[which(X.cdf >= q)[1]])
}
#####
# loading the data-set on minimum wage from Dube (2019) to obtain states that did not have a
# change of the minimum wage between 1998-2014
df <- read_dta(file.path("data", "mw_annual_lagsleads_1974_2014.dta"))
years.aff <- list()
for (ii in unique(df$state_fips)){
hh <- df$mw[df$state_fips==ii & df$year>=1996]
hh.diff <- diff(hh)
# getting the years for which the difference is 0
years.help <- df$year[df$state_fips==ii & df$year>=1996]
years.aff[[ii]] <- years.help[which(hh.diff==0)]
}
# AK is our treated unit. We want states that did not have a change between 1998 and 2003/2004
states.aff <- list()
for (ii in 1:length(years.aff)){
dummyvec <- c(1998,1999,2000,2001,2002,2003,2004)
test <- intersect(dummyvec,years.aff[[ii]])
states.aff[[ii]] <- FALSE
if (length(dummyvec) == length(test)){
if (all(dummyvec == test) == TRUE) {
states.aff[[ii]] <- TRUE
}
}
}
control.states <- which(states.aff == TRUE)
# dropping the data-set for obtaining the control states and loading the actual data
rm(df, states.aff,years.aff, dummyvec,hh,hh.diff,ii,test,years.help)
reread_dta = FALSE # redownload the replication data from the Dropbox package
if (reread_dta) {
# download the replication data
url <- "https://www.dropbox.com/s/hrmz2fu0lxet97c/Minimum%20Wage%20Poverty%20Replication.zip?dl=1"
fn <- file.path("data", "march_regready_1996.zip")
download.file(url)
unzip(fn, file.path("Minimum Wage Poverty Replication", "Data", "march_regready_1996.dta"), exdir = "data", junkpaths = TRUE)
file.remove(fn)
# load the data from the stata file
fn <- file.path("data", "march_regready_1996.dta")
df <- read_dta(fn) %>% setDT()
df <- df[, c("age", "educ", "contpov", "adj0contpov", "adj1contpov", "adj2contpov", "state_fips", "year", "hhseq", "demgroup1")]
fwrite(df, file.path("data", "march_regready_1996.csv.gz"))
file.remove(fn) # remove file to avoid github issues
} else{
df <- fread(file.path("data", "march_regready_1996.csv.gz"))
}
