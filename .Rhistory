for (i in 1:length(perc)){
perc[[i]][[1]]=t_df[[i]]
# perc.q[[i]][,1] <- mapply(myquant, evgrid, MoreArgs = list(X=t_df[[i]]))
}
keepcon=peridx[-idx]
for (i in 1:length(perc)){
for (j in 1:length(keepcon)){
perc[[i]][[j+1]] <- c_df[[i]][[keepcon[j]]]
# perc.q[[i]][,j+1] <- c_df.q[[i]][,keepcon[j]]
}
}
for (i in 1:length(perc)){
for (x in 1:length(perc[[i]])){
perc.q[[i]][,x] <- mapply(myquant, evgrid, MoreArgs = list(X=perc[[i]][[x]]))
}
}
for (i in 1:length(c_df)){
pert[[i]]=c_df[[i]][[idx]]
}
#calculate lambda_t for t<=T0
lambda_tp=list()
for (t in 1:T0){
lambda_tp[[t]] <- DiSCo_weights_reg(perc[[t]],as.vector(pert[[t]]), 1000)
}
#calculate the average optimal lambda
if (length(ww)==1){
w_t=rep(1/T0, T0)
lambda.opt=matrix(unlist(lambda_tp),ncol=T0)%*%w_t
}else{
lambda.opt=matrix(unlist(lambda_tp),ncol=T0)%*%ww
}
#calculate the barycenters for each period
bc_t=list()
for (t in 1:length(perc)){
bc_t[[t]]=DiSCo_bc(perc[[t]], perc.q[[t]], lambda.opt,evgrid)
}
# computing the target quantile function
target_q=list()
for (t in 1:length(pert)){
target_q[[t]] <- mapply(myquant, evgrid, MoreArgs = list(X=pert[[t]]))
}
c_df=controls_per
t_df=target_per
controls.q=controls.q
T0=T0
weights=Weights_DiSCo_avg
num_cores=num.cores
if (redo_weights) {
#calculate lambda_t for t<=T0
lambda_t=list()
lambda_t <- parallel::mclapply.hack(seq_len(T0), function(t) {
DiSCo_weights_reg(c_df[[t]], as.vector(t_df[[t]]), 1000)
}, mc.cores = num_cores)
#calculate the average optimal lambda
if (length(ww)==1){
w_t=rep(1/T0, T0)
lambda.opt=matrix(unlist(lambda_t),ncol=T0)%*%w_t
} else{
lambda.opt=matrix(unlist(lambda_t),ncol=T0)%*%ww
}
} else if (is.null(weights)){
stop("Please provide either weights or set redo_weights to TRUE")
} else {
lambda.opt=weights
}
#calculate the barycenters for each period
bc_t=list()
bc_t <- mclapply.hack(1:length(c_df), function(x) {
DiSCo_bc(c_df[[x]], controls.q[[x]], lambda.opt, evgrid)
}, mc.cores = num_cores)
#computing the target quantile function
target_q=list()
for (t in 1:length(t_df)){
target_q[[t]] <- mapply(myquant, evgrid, MoreArgs = list(X=t_df[[t]]))
}
#squared Wasserstein distance between the target and the corresponding barycenter
distt=c()
for (t in 1:length(c_df)){
distt[t]=mean((bc_t[[t]]-target_q[[t]])**2)
}
plot(distt, xlab='',ylab='', type='l', lwd=2)
for (i in 1:length(distp)){
lines(1:length(c_df), distp[[i]], col='grey', lwd=1)
}
abline(v=T0, lty = 2)
legend("topleft",legend = c("Target", "Control"),
col=c("black", "grey"),
lty= c(1,1), lwd = c(2,2), cex = 1.5)
title(ylab="Squared Wasserstein distance", line=2.5, cex.lab=1.5)
title(xlab="Time periods", line=3, cex.lab=1.5)
distt
distp
perm <- list(target.dist=distt, control.dist=distp)
DiSCo_per_rank <- function(distt, distp) {
#----------------------------------------#
# rank
#----------------------------------------#
#rank the squared Wasserstein distances
rankt=rank(distt)
rankp=matrix(0, nrow=length(distp), ncol=length(distp[[1]]))
for (i in 1:length(distp)){
rankp[i,]=rank(distp[[i]])
}
#----------------------------------------#
# p-value
#----------------------------------------#
#compute the p-value
pvalue=matrix(0, nrow=length(distp), ncol=length(distp[[1]]))
for (i in 1:length(distp)){
pvalue[i,]=rankp[i,]>rankt
}
pvalue=colMeans(pvalue)
return(pvalue)
}
DiSCo_per_rank <- function(distt, distp) {
#----------------------------------------#
# rank
#----------------------------------------#
#rank the squared Wasserstein distances
rankt=rank(distt)
rankp=matrix(0, nrow=length(distp), ncol=length(distp[[1]]))
for (i in 1:length(distp)){
rankp[i,]=rank(distp[[i]])
}
#----------------------------------------#
# p-value
#----------------------------------------#
#compute the p-value
pvalue=matrix(0, nrow=length(distp), ncol=length(distp[[1]]))
for (i in 1:length(distp)){
pvalue[i,]=rankp[i,]>rankt
}
# pvalue=colMeans(pvalue)
return(pvalue)
}
p_t <- DiSCo_per_rank(distp, distt)
#rank the squared Wasserstein distances
rankt=rank(distt)
rankp=matrix(0, nrow=length(distp), ncol=length(distp[[1]]))
for (i in 1:length(distp)){
rankp[i,]=rank(distp[[i]])
}
#----------------------------------------#
# p-value
#----------------------------------------#
#compute the p-value
pvalue=matrix(0, nrow=length(distp), ncol=length(distp[[1]]))
for (i in 1:length(distp)){
pvalue[i,]=rankp[i,]>rankt
}
# pvalue=colMeans(pvalue)
pvalue
distp
distt
distp
unique(df$id_col)
nunique(df$id_col)
uniqueN(df$id_col)
distt
distp
## rank the squared Wasserstein distances and get the rank of the target unit
distall <- c(distt, distp)
distall
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- c(distt, unlist(distp))
distall
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distp$control <- distt
distp
perm
distt <- perm$target.dist
distp <- perm$control.dist
distp
distall <- distp
distall$target <- distt
rankt=rank(distall)
distall
t<-1
rank(distall[[t]])
distall[[t]]
distall[[t]]
distall
matrix(distall)
test <- matrix(unlist(distall))
test
test <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[1]))
test <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[1]), byrow=TRUE)
test <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow=TRUE)
test
as.data.frame(distall)
distall <- matrix(as.data.frame(distall))
distall
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
distall
distt
distall[,t]
distall[t,]
rank(distall[t,])
nrow(distall)
1/34
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
p_values <- list()
for (t in length(distall[[1]])){
# record rank of target unit
rnk <- rank(distall[t,])
p_values <- rnk / J_1
}
p_values
plot(distt, xlab='',ylab='', type='l', lwd=2)
for (i in 1:length(distp)){
lines(1:length(c_df), distp[[i]], col='grey', lwd=1)
}
abline(v=T0, lty = 2)
legend("topleft",legend = c("Target", "Control"),
col=c("black", "grey"),
lty= c(1,1), lwd = c(2,2), cex = 1.5)
title(ylab="Squared Wasserstein distance", line=2.5, cex.lab=1.5)
title(xlab="Time periods", line=3, cex.lab=1.5)
# record rank of target unit
rnk <- rank(distall[t,])
rnk
?rank
distall[tm]
distall[t,]
t
?rank
# record rank of target unit
rnk <- rank(-distall[t,])
rnk
distall[t]
distall[t,]
distall[,t]
distal
distall
length(distall[[1]])
ncol(distall)
# record rank of target unit
rnk <- rank(-distall[,t])
rnk
distall
distt
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
rnk
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values <- rnk / J_1
}
p_values
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
}
p_values
plot(distt, xlab='',ylab='', type='l', lwd=2)
for (i in 1:length(distp)){
lines(1:length(c_df), distp[[i]], col='grey', lwd=1)
}
abline(v=T0, lty = 2)
legend("topleft",legend = c("Target", "Control"),
col=c("black", "grey"),
lty= c(1,1), lwd = c(2,2), cex = 1.5)
title(ylab="Squared Wasserstein distance", line=2.5, cex.lab=1.5)
title(xlab="Time periods", line=3, cex.lab=1.5)
DiSCo_per_rank <- function(distt, distp) {
#' @param distt List of squared Wasserstein distances between the target unit and the control units
#' @param distp List of squared Wasserstein distances between the control units
#' @return List of p-values for each time period
#' @export
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
}
return(pvalues)
}
p_values <- DiSCo_per_rank(perm$control.dist, perm$target.dist)
perm$target.dist
perm$control.dist
DiSCo_per_rank <- function(distt, distp) {
#' @param distt List of squared Wasserstein distances between the target unit and the control units
#' @param distp List of squared Wasserstein distances between the control units
#' @return List of p-values for each time period
#' @export
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
}
return(pvalues)
}
DiSCo_per_rank <- function(distt, distp) {
#' @param distt List of squared Wasserstein distances between the target unit and the control units
#' @param distp List of squared Wasserstein distances between the control units
#' @return List of p-values for each time period
#' @export
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
}
return(p_values)
}
p_values <- DiSCo_per_rank(perm$control.dist, perm$target.dist)
perm$control.dist
perm$target.dist
distp <- perm$control.dist
distt <- perm$target.dist
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
}
DiSCo_per_rank <- function(distt, distp) {
#' @param distt List of squared Wasserstein distances between the target unit and the control units
#' @param distp List of squared Wasserstein distances between the control units
#' @return List of p-values for each time period
#' @export
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
}
return(p_values)
}
p_values <- DiSCo_per_rank(perm$control.dist, perm$target.dist)
distp <- perm$control.dist
distt <- perm$target.dist
p_values <- DiSCo_per_rank(distt, distp)
p_values
p_values
controls
length(controls)
DiSCo_per_rank <- function(distt, distp) {
#' @param distt List of squared Wasserstein distances between the target unit and the control units
#' @param distp List of squared Wasserstein distances between the control units
#' @return List of p-values for each time period
#' @export
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
rnks <- list()
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
ranks[[t]] <- rnk
}
p_values <- unlist(p_values)
p_overall <- mean(ranks) / J_1
return(list(p_t = p_values, p_overall = p_overall))
}
perm_values <- DiSCo_per_rank(distt, distp)
DiSCo_per_rank <- function(distt, distp) {
#' @param distt List of squared Wasserstein distances between the target unit and the control units
#' @param distp List of squared Wasserstein distances between the control units
#' @return List of p-values for each time period
#' @export
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
rnks <- list()
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
rnks[[t]] <- rnk
}
p_values <- unlist(p_values)
p_overall <- mean(rnks) / J_1
return(list(p_t = p_values, p_overall = p_overall))
}
perm_values <- DiSCo_per_rank(distt, distp)
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
rnks <- list()
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
rnks[[t]] <- rnk
}
p_values <- unlist(p_values)
rnks
mean(rnks)
rnks
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
rnks <- numeric(ncol(distall))
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
rnks[t] <- rnk
}
p_values <- unlist(p_values)
p_overall <- mean(rnks) / J_1
p_overall
DiSCo_per_rank <- function(distt, distp) {
#' @param distt List of squared Wasserstein distances between the target unit and the control units
#' @param distp List of squared Wasserstein distances between the control units
#' @return List of p-values for each time period
#' @export
## rank the squared Wasserstein distances and get the rank of the target unit
# combine distt and distp
distall <- distp
distall$target <- distt
distall <- matrix(unlist(distall), nrow=length(distall), ncol=length(distall[[1]]), byrow = TRUE)
J_1 <- nrow(distall)
rnks <- list()
p_values <- list()
for (t in 1:ncol(distall)){
# record rank of target unit
rnk <- rank(-distall[,t])[J_1]
p_values[[t]] <- rnk / J_1
rnks[[t]] <- rnk
}
p_values <- unlist(p_values)
return(list(p_t = p_values, ranks=rnks))
}
perm_values <- DiSCo_per_rank(distt, distp)
length(distp)
p_overall <- unlist(perm_values$ranks)[(T_0+1:T_max)] / (length(distp) + 1)
p_overall <- unlist(perm_values$ranks)[(T0+1:T_max)] / (length(distp) + 1)
p_overall
unlist(perm_values$ranks)
T0
T_max
unlist(perm_values$ranks)[((T0+1):T_max)]
p_overall <- mean(unlist(perm_values$ranks)[((T0+1):T_max)]) / (length(distp) + 1)
p_overall
bc
# calculating the counterfactual target distribution
bc <- lapply(seq(1:T_max), function(x) DiSCo_bc(results.periods[[x]]$controls$data, results.periods[[x]]$controls.q, Weights_DiSCo_avg, evgrid))
names(bc) <- t_min  + seq(1:T_max) - 1
bc
results.periods$`1`$target
bc
length(target)
length(bc)
length(results.periods$`1`$target)
results.periods$`1`$target
length(results.periods$`1`$target$data)
length(bc)
length(bc[[1]])
length(results.periods$`1`$target$cdf)
length(results.periods$`1`$target$grid)
bc
