}
if (!is.numeric(M)) {
stop("M must be numeric")
}
if (!is.integer(G)) {
stop("G must be integer")
}
if (!is.integer(num.cores)) {
stop("num.cores must be integer")
}
if (!is.logical(permutation)) {
stop("permutation must be logical")
}
# checks on the input data values
if ((t0 < min(df$time_col)) | (t0 > max(df$time_col))) {
stop("T0 must be between minimum and the maximum value of year_col")
}
if (M < (uniqueN(df$id_col) -1) ) {
stop("M must be greater than or equal to the number of control units, and ideally large")
}
if (G < 2) {
stop("G must be greater than or equal to 2, and ideally larger than 100")
}
if (num.cores < 1) {
stop("num.cores must be greater than or equal to 1")
}
# check that the number of cores is not greater than the number of available cores
if (num.cores > parallel::detectCores()) {
stop("num.cores cannot be greater than the number of available cores")
}
if (!is.logical(CI)) {
stop("CI must be logical")
}
if (!is.integer(boots)) {
stop("boot must be integer")
}
if ((CI) & (boots < 2)) {
stop("IF CI=TRUE, boot must be greater than or equal to 2 (and ideally greater than 100)")
}
# check if cl is decimal number between 0 and 1
if (!is.numeric(cl)) {
stop("cl must be numeric")
}
if ((cl < 0) | (cl > 1)) {
stop("cl must be between 0 and 1")
}
if (!is.logical(graph)) {
stop("graph must be logical")
}
if (!is.numeric(q_min)) {
stop("q_min must be numeric")
}
if (!is.numeric(q_max)) {
stop("q_max must be numeric")
}
if (q_min < 0) {
stop("q_min must be greater than or equal to 0")
}
if (q_max > 1) {
stop("q_max must be less than or equal to 1")
}
if (q_min > q_max) {
stop("q_min must be less than or equal to q_max")
}
if (!is.logical(CI_placebo)) {
stop("CI_placebo must be logical")
}
if (!is.null(qmethod)) {
if (!qmethod %in% c("smooth", "extreme")) {
stop("qmethod must be either NULL, 'smooth' or 'extre,e'")
}
}
if (!is.null(seed)) {
if (!is.integer(seed)) {
stop("seed must be NULL or integer")
}
}
}
#' Check if a vector is integer
#'
#' @param x a vector
#' @return TRUE if x is integer, FALSE otherwise
#' @keywords internal
is.integer <- function(x) {
is.numeric(x) && all(x == as.integer(x))
}
#' @title mclapply.hack
#'
#' @description This function mimics forking (done with mclapply in Mac or Linux) for the
#' Windows environment.  Designed to be used just like mclapply.  Credit goes to
#' Nathan VanHoudnos.
#' @param verbose Should users be warned this is hack-y? Defaults to FALSE.
#' @seealso mclapply
#' @keywords internal
#' @importFrom parallel makeCluster detectCores parLapply stopCluster clusterExport
#' @importFrom utils sessionInfo
mclapply.hack <- function(..., verbose=FALSE, mc.cores=NULL) {
if (mc.cores == 1) {
return(lapply(...))
}
if( Sys.info()[['sysname']] == 'Windows') {
## Create a cluster
if( is.null(mc.cores) ) {
size.of.list <- length(list(...)[[1]])
mc.cores <- min(size.of.list, detectCores())
}
## N.B. setting outfile to blank redirects output to
##      the master console, as is the default with
##      mclapply() on Linux / Mac
cl <- makeCluster( mc.cores, outfile="" )
## Find out the names of the loaded packages
loaded.package.names <- c(
## Base packages
utils::sessionInfo()$basePkgs,
## Additional packages
names( sessionInfo()$otherPkgs ))
tryCatch( {
## Copy over all of the objects within scope to
## all clusters.
this.env <- environment()
while( identical( this.env, globalenv() ) == FALSE ) {
clusterExport(cl,
ls(all.names=TRUE, envir=this.env),
envir=this.env)
this.env <- parent.env(environment())
}
clusterExport(cl,
ls(all.names=TRUE, envir=globalenv()),
envir=globalenv())
## Load the libraries on all the clusters
## N.B. length(cl) returns the number of clusters
parLapply( cl, 1:length(cl), function(xx){
lapply(loaded.package.names, function(yy) {
require(yy , character.only=TRUE)})
})
## Run the lapply in parallel
return( parLapply( cl, ...) )
}, finally = {
## Stop the cluster
stopCluster(cl)
})
## Warn the user if they are using Windows
if(verbose == TRUE){
message(paste(
"\n",
"   *** Microsoft Windows detected ***\n",
"   \n",
"   For technical reasons, the MS Windows version of mclapply()\n",
"   is implemented as a serial function instead of a parallel\n",
"   function.",
"   \n\n",
"   As a quick hack, we replace this serial version of mclapply()\n",
"   with a wrapper to parLapply() for this R session. Please see\n\n",
"     http://www.stat.cmu.edu/~nmv/2014/07/14/implementing-mclapply-on-windows \n\n",
"   for details.\n\n"))
}
} else{
## If not on Windows, just call mclapply()
parallel::mclapply(..., mc.cores=mc.cores)
}
}
#' @title citation
#'
#' @description print the citation for the relevant paper
#'
#' @keywords internal
citation <- function() {
cat('Reference: Gunsilius, Florian F. "Distributional synthetic controls." Econometrica 91, no. 3 (2023): 1105-1117. \n')
}
#' @title ex_gmm
#'
#' @description Example data for \code{DiSCo} command.
#' There are 30 control units, each has a distribution of a mixture of 3 Gaussian distributions.
#' The target has a distribution of a mixture of 4 Gaussian distributions.
#'
#' @keywords internal
#' @param t an integer indicating the number of time periods
#' @param num.con an integer indicating the number of control units
#' @param numdraws an integer indicating the number of draws
#' @return
#' \item{\code{target}}{a vector.}
#' \item{\code{control}}{a matrix.}
#' @importFrom MASS mvrnorm
#' @importFrom stats runif
ex_gmm=function(Ts=2, num.con=30, numdraws=1000){
for (t in 1:Ts) {
# Mixture of 3 Gaussians
con <- matrix(0, nrow=num.con, ncol=numdraws)
for (ii in 1:num.con){
# generating uniformly distributed weights in the unit simplex
a1 <- matrix(runif(3), nrow=1)
a1 <- sweep(a1, 1, rowSums(a1), FUN="/")
components <- sample(1:3,prob=a1,size=numdraws,replace=TRUE)
mus <- runif(3,-10,10)
sigmas <- runif(3,0.5,6)
sigmas <- (sigmas + t(sigmas))/2
con[ii,] <- rnorm(numdraws)*sigmas[components]+mus[components]
}
# generating the target distribution as a mixture of 4 Normals
a1 <- matrix(runif(4), nrow=1)
a1 <- sweep(a1, 1, rowSums(a1), FUN="/")
components <- sample(1:4,prob=a1,size=numdraws,replace=TRUE)
mus <- runif(4,-10,10)
sigmas <- runif(4,0.5,6)
sigmas <- (sigmas + t(sigmas))/2
treat <- rnorm(numdraws)*sigmas[components]+mus[components]
con <- t(con)
target <- treat
# stick in dataframe
df <- data.table(target=target, control=con)
# convert to long format
df <- melt(df, id.vars = NULL, measure.vars = c("target", paste0("control.V", 1:num.con)))
setnames(df, c("variable", "value"), c("id_col", "y_col"))
df[, time_col := t]
if (t==1) df_out <- df
else df_out <- rbind(df_out, df)
}
df_out[, id_col := as.numeric(id_col)]
return(df_out)
}
DiSCo(df=df, id_col.target=1, t0=t0, M=M, seed=1)
M
uniqueN(df$id_col)
M
M < (uniqueN(df$id_col) -1)
DiSCo(df=df, id_col.target=1, t0=t0, M=M, seed=1)
devtools::load_all()
DiSCo(df=df, id_col.target=1, t0=t0, M=M, seed=1)
G <- 2
DiSCo(df=df, id_col.target=1, t0=t0, G=G, seed=1)
M <- num.con
expect_no_error(DiSCo(df=df, id_col.target=1, t0=t0, M=M, seed=1))
# G just large enough
G <- 2
expect_no_error(DiSCo(df=df, id_col.target=1, t0=t0, G=G, seed=1))
# G too small
G <- 1
expect_error(DiSCo(df=df, id_col.target=1, t0=t0, G=G, seed=1))
# M just large enough
M <- num.con
expect_no_error(DiSCo(df=df, id_col.target=1, t0=t0, M=M, seed=1))
?DiSco
# id_col.targt not in df
id_col.target <- max(df$id_col) + 1
DiSCo(df=df, id_col.target=id_col.target, t0=t0, seed=1)
expect_error(DiSCo(df=df, id_col.target=id_col.target, t0=t0, seed=1))
num.cores <- 100
expect_error(DiSCo(df=df, id_col.target=1, t0=t0, num.cores=num.cores, seed=1))
# permutation TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, permutation=TRUE, seed=1))
disco$perm
expect_true(!is.null(disco$perm))
# permutation FALSE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, permutation=FALSE, seed=1))
expect_true(is.null(disco$perm))
# q_min too small
q_min <- -1
DiSCo(df=df, id_col.target=1, t0=t0, q_min=q_min, seed=1)
# q_max too large
q_max <- 2
DiSCo(df=df, id_col.target=1, t0=t0, q_max=q_max, seed=1)
expect_error(DiSCo(df=df, id_col.target=1, t0=t0, q_max=q_max, seed=1))
# q_min and q_max normal range
q_min <- 0.2
q_max <- 0.8
expect_no_error(DiSCo(df=df, id_col.target=1, t0=t0, q_min=q_min, q_max=q_max, seed=1))
# q_min larger than q_max
q_min <- 0.8
q_max <- 0.2
expect_error(DiSCo(df=df, id_col.target=1, t0=t0, q_min=q_min, q_max=q_max, seed=1))
DiSCo(df=df, id_col.target=1, t0=t0, q_min=q_min, q_max=q_max, seed=1)
# CI TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, CI=TRUE, seed=1))
disco$results.periods[[1]]$DiSCo$CI
expect_true(!is.null(disco$results.periods[[1]]$CI))
expect_true(!is.null(disco$results.periods[[1]]$DiSCo$CI))
# CI FALSE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, CI=FALSE, seed=1))
expect_true(is.null(disco$results.periods[[1]]$DiSCo$CI))
?DiSCo
# CI_placebo TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, CI_placebo=TRUE, seed=1))
disco$results.periods[[1]]$CI
# CI_placebo TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, CI_placebo=TRUE, CI=TRUE, seed=1))
# parallel cores
num.cores <- 2
expect_no_error(DiSCo(df=df, id_col.target=1, t0=t0, num.cores=num.cores, seed=1))
# CI_placebo TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, CI_placebo=TRUE, CI=TRUE, seed=1))
disco$results.periods[[1]]$CI
disco$results.periods[[1]]$DiSCo$CI
expect_true(!is.null(disco$results.periods[[1]]$DiSCo$CI_placebo))
expect_true(!is.null(disco$results.periods[[1]]$DiSCo$CI))
# CI_placebo FALSE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, CI_placebo=FALSE, CI=TRUE, seed=1, num.cores=2))
expect_true(is.null(disco$results.periods[[1]]$DiSCo$CI))
# boots 0
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, boots=0, seed=1))
# boots 0
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, boots=0, seed=1, CI=TRUE, num.cores=2))
# boots 0
expect_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, boots=0, seed=1, CI=TRUE, num.cores=2))
# boots 2
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, boots=2, seed=1, CI=TRUE, num.cores=2))
disco$results.periods[[1]]$DiSCo$CI
expect_true(!is.null(disco$results.periods[[1]]$DiSCo$CI))
expect_true(!is.null(disco$results.periods[[1]]$DiSCo$CI))
# cl = 0
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, cl=0, seed=1, CI=TRUE, num.cores=2))
dim(disco$results.periods[[1]]$DiSCo$CI)
disco$results.periods[[1]]$DiSCo$CI
dim(disco$results.periods[[1]]$DiSCo$CI$bootmat)
# cl = 0
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, cl=0, seed=1, CI=TRUE, num.cores=2, boot=2))
dim(disco$results.periods[[1]]$DiSCo$CI$bootmat)
length(disco$results.periods[[1]]$DiSCo$CI$bootmat[,1])
disco$results.periods[[1]]$DiSCo$CI$bootmat[,1] == disco$results.periods[[1]]$DiSCo$quantile
disco$results.periods[[1]]$DiSCo$CI$lower == disco$results.periods[[1]]$DiSCo$CI$upper
all(disco$results.periods[[1]]$DiSCo$CI$bootmat[,1] == disco$results.periods[[1]]$DiSCo$quantile)
sum(disco$results.periods[[1]]$DiSCo$CI$bootmat[,1] == disco$results.periods[[1]]$DiSCo$quantile)
all(disco$results.periods[[1]]$DiSCo$CI$lower == disco$results.periods[[1]]$DiSCo$CI$upper)
# cl = 1
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, cl=1, seed=1, CI=TRUE, num.cores=2, boot=2))
# cl < 0
expect_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, cl=-1, seed=1, CI=TRUE, num.cores=2, boot=2))
# cl > 1
expect_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, cl=2, seed=1, CI=TRUE, num.cores=2, boot=2))
# graph FALSE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, graph=FALSE, seed=1, CI=TRUE, num.cores=2, boot=2))
# graph FALSE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, graph=FALSE, seed=1))
# graph TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, graph=TRUE, seed=1))
# graph FALSE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, graph=FALSE, seed=1))
disco$perm
# graph TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, graph=TRUE, seed=1))
# qmethod = "smooth"
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, qmethod="smooth", seed=1, CI=TRUE, num.cores=2, boot=2))
# qmethod = "qkden"
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, qmethod="qkden", seed=1, CI=TRUE, num.cores=2, boot=2))
devtools::load_all()
# qmethod = "qkden"
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, qmethod="qkden", seed=1, CI=TRUE, num.cores=2, boot=2))
# qmethod = "qkden"
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, qmethod="qkden", seed=1, num.cores=2))
# qmethod = "extreme"
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, qmethod="extreme", seed=1, num.cores=2))
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, num.cores=2))
expect_no_error(disco2 <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, num.cores=2))
expect_equal(disco$Weights_DiSCo_avg, disco$Weights_DiSCo_avg)
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, num.cores=2, simplex=TRUE))
expect_true(all(disco$Weights_DiSCo_avg >= 0))
disco$Weights_DiSCo_avg
# test simplex=TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, num.cores=2, simplex=FALSE))
disco$Weights_DiSCo_avg
# expect true up to some margin of error
expect_true(all(disco$Weights_DiSCo_avg > -1e-10))
# test simplex=TRUE
expect_no_error(disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, num.cores=2, simplex=TRUE))
# expect true up to some margin of error
expect_true(all(disco$Weights_DiSCo_avg > -1e-10))
?DiSCoTEA
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1)
expect_no_error(discot <- DiSCoTEA(disco, agg="quantile"))
discot$plot
type(discot$plot)
typeof(discot$plot)
expect_true(typeof(discot$plot) == "list")
summary(discot)
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1)
expect_no_error(discot <- DiSCoTEA(disco, agg="cdf"))
expect_true(typeof(discot$plot) == "list")
expect_no_error(summary(discot))
discot$treats
discot$ci_lower
discot$ci_upper
expect_true(!is.null(discot$treats))
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1,  CI=TRUE, boots=2)
expect_no_error(discot <- DiSCoTEA(disco, agg="quantileDiff"))
expect_true(typeof(discot$plot) == "list")
expect_no_error(summary(discot))
expect_true(!is.null(discot$treats))
expect_true(!is.null(discot$ses))
expect_true(!is.null(discot$ci_lower))
expect_true(!is.null(discot$ci_upper))
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
expect_no_error(discot <- DiSCoTEA(disco, agg="quantileDiff"))
expect_true(typeof(discot$plot) == "list")
expect_no_error(summary(discot))
expect_true(!is.null(discot$treats))
expect_true(!is.null(discot$ses))
expect_true(!is.null(discot$ci_lower))
expect_true(!is.null(discot$ci_upper))
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
expect_no_error(discot <- DiSCoTEA(disco, samples=c(0.1, 0.2, 0.5, 0.9)))
discot$agg_df
smpls <- c(0.1, 0.2, 0.5, 0.9)
expect_equal(discot$agg_df$X_from, c(0, smpls))
expect_equal(discot$agg_df$X_to, c(smpls, 1))
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
smpls <- c()
expect_error(discot <- DiSCoTEA(disco, samples=smpls))
summary(discot)
smpls <- c(-100, 0.5, 100)
expect_error(discot <- DiSCoTEA(disco, samples=smpls))
summary(discot)
discot <- DiSCoTEA(disco, samples=smpls)
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
smpls <- c(0.5, 100)
expect_error(discot <- DiSCoTEA(disco, samples=smpls))
summary(discot)
discot <- DiSCoTEA(disco, samples=smpls)
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
smpls <- c(0.5, 100)
expect_error(discot <- DiSCoTEA(disco, samples=smpls))
library(testthat)
library(DiSCo)
test_check("DiSCo")
devtools::check()
?devtools::check
devtools::check(vignettes=FALSE)
devtools::check(vignettes=FALSE)
pkgdown::build_site()
devtools::check(vignettes=FALSE)
devtools::build()
devtools::test()
devtools::build(vignettes=FALSE)
devtools::check(vignettes=FALSE)
devtools::build(vignette=FALSE)
rhub::check_for_cran()
devtools::document()
rhub::check_for_cran()
?check_for_cran
devtools::load_all()
library(rhub)
?check_for_cran
?test
devtools::document()
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
smpls <- c(0.1, 0.2, 0.5, 0.9)
expect_no_error(discot <- DiSCoTEA(disco, samples=smpls))
expect_equal(discot$agg_df$X_from, c(0, smpls))
expect_equal(discot$agg_df$X_to, c(smpls, 1))
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
smpls <- c(0.5, 100)
expect_error(discot <- DiSCoTEA(disco, samples=smpls))
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
smpls <- c(0.5, 100)
discot <- DiSCoTEA(disco, samples=smpls)
?test
?check
rhub::check()
devtools::check()
devtools::test()
devtools::load_all()
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
expect_no_error(discot <- DiSCoTEA(disco, agg="quantile"))
expect_true(typeof(discot$plot) == "list")
expect_no_error(summary(discot))
expect_true(!is.null(discot$treats))
expect_true(!is.null(discot$ses))
expect_true(!is.null(discot$ci_lower))
expect_true(!is.null(discot$ci_upper))
Ts <- 2
t0 <- 2
df <- ex_gmm(Ts=Ts)
disco <- DiSCo(df=df, id_col.target=1, t0=t0, seed=1, CI=TRUE, boots=2)
smpls <- c(0.1, 0.2, 0.5, 0.9)
expect_no_error(discot <- DiSCoTEA(disco, samples=smpls))
expect_equal(discot$agg_df$X_from, c(0, smpls))
expect_equal(discot$agg_df$X_to, c(smpls, 1))
devtools::check()
